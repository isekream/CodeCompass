# Angular Rules

## General Principles & Style

* **Follow JS/TS Rules:** Adhere to all rules defined in `javascript_typescript_rules.md`.
* **Angular Style Guide:** Follow the official Angular Style Guide for conventions regarding file naming, code structure, naming conventions, and application structure.
* **Angular CLI:** Use the Angular CLI (`ng`) for generating components, services, modules, directives, pipes, and for building, serving, and testing the application. Adhere to the default project structure generated by the CLI.
* **Consistency:** Maintain consistency in naming, file structure, and coding patterns throughout the project.
* **Readability:** Write clean, readable, and maintainable code. Keep functions and components small and focused. Limit file line count (e.g., < 400 lines).
* **Avoid `any`:** Minimize the use of the `any` type. Use specific types, interfaces, or `unknown` with type guards. Enable strict mode in `tsconfig.json`.

## Project Structure

* **Standard CLI Structure:** Maintain the standard folder structure generated by Angular CLI (`src/app`, `src/assets`, `src/environments`).
* **Feature Modules (or Standalone Components):** Organize the application into feature modules (using `NgModule`) or leverage standalone components (recommended in modern Angular) grouped into logical feature directories.
* **Core Module/Directory:** Create a `Core` module (or directory for standalone) for singleton services, application-wide components (e.g., layout, header, footer), and guards that are imported *only* by the root module (`AppModule` or `AppComponent` for standalone).
* **Shared Module/Directory:** Create a `Shared` module (or directory for standalone) for commonly used components, directives, and pipes that are needed across multiple feature modules/components. Import the `SharedModule` (or individual standalone components/directives/pipes) into the feature modules/components that need them. Do *not* provide services here.
* **File Naming:** Follow the convention `feature.type.ts` (e.g., `user-profile.component.ts`, `auth.guard.ts`, `order-history.service.ts`, `app.routes.ts`). Use dots (`.`) to separate name, type, and extension; use hyphens (`-`) to separate words in the name.

## Components

* **Standalone Components:** Prefer standalone components, directives, and pipes (introduced in Angular 14+) over `NgModule` based structures for simpler architecture and better tree-shaking.
* **Single Responsibility:** Components should have a single, well-defined responsibility, primarily focused on presentation logic (displaying data and delegating user actions).
* **Component Size:** Keep components small and focused. If a component becomes too large or complex (e.g., > 75-100 lines of code), refactor it into smaller sub-components.
* **`@Input()` and `@Output()`:** Use `@Input()` decorators for passing data *into* a component and `@Output()` decorators (with `EventEmitter`) for sending events *out* of a component. Avoid direct parent/child dependencies.
* **Naming:** Use `PascalCase` for component class names (e.g., `UserProfileComponent`). Use `kebab-case` for selectors (`app-user-profile`), file names (`user-profile.component.ts`), and associated template/style files.
* **Lifecycle Hooks:** Implement lifecycle hook interfaces (`OnInit`, `OnDestroy`, etc.) as needed. Keep logic within lifecycle hooks concise; delegate complex operations to methods called from the hooks. Implement `OnDestroy` to clean up subscriptions and avoid memory leaks.
* **Change Detection:**
    * Use the `OnPush` change detection strategy (`changeDetection: ChangeDetectionStrategy.OnPush`) for components whenever possible, especially for "dumb" or presentational components. This improves performance by reducing the number of change detection cycles.
    * Ensure that `@Input` properties use immutable data structures or new object references when `OnPush` is used to trigger change detection correctly.
* **Smart vs. Dumb Components:** Consider separating components into "smart" (container) components that manage state and fetch data, and "dumb" (presentational) components that receive data via `@Input` and emit events via `@Output`.

## Templates & Styling

* **Template Syntax:** Use clear and concise template syntax. Avoid complex logic directly in templates; move it to the component class or pipes.
* **`*ngFor` Optimization:** Use `trackBy` with `*ngFor` when iterating over lists, especially if the list can change (additions, removals, reordering), to improve rendering performance by helping Angular track items.
* **`async` Pipe:** Use the `async` pipe (`| async`) in templates to subscribe and unsubscribe from Observables automatically. This is the preferred way to handle observable data in templates and helps prevent memory leaks.
* **Scoped Styles:** Use component-scoped styles (default encapsulation `ViewEncapsulation.Emulated`) to prevent styles from leaking out and affecting other components. Define styles in the `styles` or `styleUrls` property of the `@Component` decorator. Avoid `::ng-deep` where possible; use CSS Custom Properties or other customization methods if needed.
* **Conditional Classes/Styles:** Use `[ngClass]` and `[ngStyle]` for applying dynamic CSS classes and inline styles.

## Services & Dependency Injection (DI)

* **Purpose:** Use services for shared logic, data fetching, state management, and encapsulating business logic. Keep components focused on presentation.
* **`providedIn: 'root'`:** Provide application-wide singleton services using `@Injectable({ providedIn: 'root' })`. This makes services tree-shakable.
* **Scoped Providers:** Provide services at the component level (`providers` array in `@Component`) only when you need a separate instance of the service for each component instance or its subtree.
* **Constructor Injection:** Use constructor injection to provide dependencies to classes (components, services, directives).
* **Injection Tokens:** Use `InjectionToken` for providing non-class dependencies (like configuration objects or primitive values).
* **`HttpClient`:** Use the `HttpClient` service (from `@angular/common/http`) for making HTTP requests. Handle responses using RxJS Observables.

## State Management

* **Simple State:** For simple component state, use component properties. For state shared between closely related components (parent/child), use `@Input`/`@Output`.
* **Service State:** For state shared across different parts of the application, manage it within an Angular service (often using RxJS `BehaviorSubject` or `Signal` for reactive updates).
* **Dedicated Libraries:** For complex state management scenarios, consider using dedicated state management libraries like NgRx (Redux pattern), NGXS, or Elf. Evaluate the complexity trade-off.
* **Signals (Angular 16+):** Leverage Angular Signals for fine-grained reactivity and potentially simpler state management compared to RxJS for certain use cases.

## RxJS Usage

* **Embrace Observables:** Use RxJS Observables extensively for handling asynchronous operations (HTTP requests, events, state changes).
* **Avoid Nested Subscriptions:** Do NOT subscribe within another subscription (`subscribe` inside `subscribe`). Use higher-order mapping operators (`switchMap`, `mergeMap`, `concatMap`, `exhaustMap`) to chain dependent asynchronous operations. Choose the appropriate operator based on the desired behavior (canceling, merging, ordering).
* **Unsubscribe:** Prevent memory leaks by unsubscribing from observables when a component is destroyed. Common patterns:
    * Use the `async` pipe in templates (preferred).
    * Use a `Subject` combined with the `takeUntil` operator in the component's `ngOnDestroy` method.
    * Use `take(1)` if you only need the first emitted value.
* **Use Operators:** Leverage RxJS operators (`map`, `filter`, `tap`, `debounceTime`, `distinctUntilChanged`, `catchError`, etc.) to manipulate and combine observable streams declaratively.
* **Error Handling:** Use the `catchError` operator to handle errors within observable pipelines gracefully.
* **Sharing Observables:** Use sharing operators like `shareReplay({ bufferSize: 1, refCount: true })` when an observable stream needs to be subscribed to multiple times without re-executing the source logic (e.g., multiple `async` pipes binding to the same HTTP request observable).

## Performance

* **Lazy Loading:** Implement lazy loading for feature modules using `loadChildren` (classic NgModules) or `loadComponent` (standalone components) in routing configurations. This speeds up initial application load time by only loading necessary code chunks on demand.
* **AOT Compilation:** Always build for production using Ahead-of-Time (AOT) compilation (`ng build --configuration production`), which is the default. AOT improves runtime performance and catches template errors during the build.
* **Change Detection Strategy:** Use `ChangeDetectionStrategy.OnPush` where possible (see Components section).
* **Bundle Size:** Monitor application bundle size using tools like `webpack-bundle-analyzer` (integrated via `ng build --stats-json`). Remove unused code and dependencies. Optimize assets (images, fonts).
* **`trackBy`:** Use `trackBy` with `*ngFor` (see Templates section).
* **Optimize RxJS:** Use RxJS operators efficiently; avoid unnecessary computations within observable streams.

## Security

* **XSS Prevention:** Angular provides built-in protection against common Cross-Site Scripting (XSS) attacks by automatically sanitizing or escaping values bound in templates. Trust Angular's sanitization unless you have a specific reason to bypass it using methods like `bypassSecurityTrustHtml` (use with extreme caution and only on trusted content).
* **Avoid Risky APIs:** Do not directly manipulate the DOM using `ElementRef.nativeElement` where avoidable. Use Angular's template syntax, data binding, and Renderer2 methods instead.
* **Template Injection:** Do not generate Angular templates by concatenating user input strings. Use the Angular template compiler.
* **HTTP Security:**
    * Use `HttpClient` which has built-in support for preventing Cross-Site Request Forgery (XSRF/CSRF). Ensure your backend cooperates with the standard XSRF token mechanism (e.g., `X-XSRF-TOKEN` header).
    * Communicate with backends over HTTPS.
* **Content Security Policy (CSP):** Implement a strict CSP header on the server to mitigate XSS and data injection attacks.
* **Keep Angular Updated:** Regularly update Angular framework and CLI versions (`ng update`) to receive security patches and fixes.

## Testing

* **Follow Testing Rules:** Adhere to general testing best practices.
* **Frameworks:** Use Angular's built-in testing framework (based on Jasmine and Karma by default, or Jest via builders) for unit and integration tests. Use Protractor (deprecated) or modern alternatives like Cypress or Playwright for end-to-end (E2E) tests.
* **Unit Tests (`.spec.ts`):** Write unit tests for components, services, pipes, and directives. Focus on testing a single unit in isolation. Use `TestBed` for configuring the testing module and providing mocks/stubs for dependencies.
* **Integration Tests:** Test component interactions, template bindings, and service integrations using `TestBed`.
* **Mocking:** Mock dependencies (services, child components) effectively in unit tests.
* **Coverage:** Aim for meaningful test coverage. Use `ng test --coverage` to generate reports.

## Routing

* **Route Configuration:** Define routes in a separate routing module (e.g., `app-routing.module.ts`) or a dedicated routes file (for standalone). Use the appropriate route configuration properties (`path`, `component`, `loadChildren`, `loadComponent`, `canActivate`, etc.).
* **Lazy Loading:** Implement lazy loading for feature modules or standalone components to improve initial load performance.
* **Route Guards:** Use route guards (`CanActivate`, `CanDeactivate`, `Resolve`, etc.) to control access to routes based on conditions (e.g., authentication state, unsaved changes).
* **Route Parameters:** Use route parameters to pass data via URL (`/users/:id`). Use query parameters for optional or filter-related data.
* **Navigation:** Prefer declarative navigation using the `routerLink` directive in templates over programmatic navigation with `Router.navigate()`.
* **Child Routes:** Use child routes to organize routes hierarchically, especially for feature modules with their own routing concerns.

## Forms

* **Form Types:** Choose the appropriate form approach:
    * **Reactive Forms:** Preferred for complex forms with dynamic controls, custom validation, and complex form state. Create form models in the component class using `FormGroup`, `FormControl`, `FormArray`, etc.
    * **Template-Driven Forms:** Suitable for simple forms with more static structure. Use directives like `ngModel`, `ngForm`, etc., in the template.
* **Validation:** Implement form validation using built-in validators or custom validators. Display meaningful error messages to guide users.
* **Form State:** Track form state (`pristine/dirty`, `valid/invalid`, `touched/untouched`) to provide appropriate feedback and control form submission.
* **Form Submission:** Handle form submission appropriately, often by triggering an HTTP request via a service when the form is valid.
