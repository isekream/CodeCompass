# Svelte & SvelteKit Rules

## General Principles & Style

* **Follow JS/TS Rules:** Adhere to all rules defined in `javascript_typescript_rules.md`.
* **Consistency:** Maintain consistency in naming, file structure, and coding patterns. Use linters (ESLint with `eslint-plugin-svelte`) and formatters (Prettier with `prettier-plugin-svelte`) configured for Svelte projects.
* **Svelte Files (`.svelte`):** Use Single File Components (SFCs) for UI elements, encapsulating script, template (markup), and style.
* **Simplicity:** Leverage Svelte's compiler-based approach and reactivity model to write concise and declarative code. Avoid unnecessary complexity.

## Project Structure (SvelteKit Focus)

* **Standard SvelteKit Structure:** Utilize the standard project structure generated by `npm create svelte@latest`:
    * `src/routes/`: Defines the file-based routing structure. Folders create path segments, `+page.svelte` defines page components, `+layout.svelte` defines layouts, `+server.js` (or `.ts`) defines API endpoints.
    * `src/lib/`: Stores library code (components, utilities, stores) intended to be used across the application. Code here can be imported using the `$lib` alias.
    * `src/params/`: Defines custom parameter matchers for routing.
    * `src/hooks.server.js` / `src/hooks.client.js`: Define server-side and client-side hooks.
    * `src/service-worker.js`: Define service worker logic.
    * `static/`: Stores static assets that are served directly without processing.
* **Component Organization:** Within `src/lib/components/` (or similar), organize reusable components logically, potentially by feature or type.

## Components (`.svelte` files)

* **Single Responsibility:** Components should ideally focus on one primary purpose or piece of UI. Break down complex components into smaller, reusable sub-components.
* **File Naming:** Use `PascalCase` for component file names (e.g., `UserProfile.svelte`, `BaseButton.svelte`).
* **Props (`export let`)**:
    * Declare props using `export let propName;`.
    * Provide default values if a prop is optional (`export let count = 0;`).
    * Use TypeScript interfaces (in `<script lang="ts">`) for complex prop types (`export let user: UserProfile;`).
* **Events:**
    * Dispatch events using `createEventDispatcher` from `svelte`.
    * Use `kebab-case` for event names when dispatching (`dispatch('user-update', user)`). Listen using `on:user-update`.
    * Pass relevant data with the event (`e.detail` in the handler).
* **Slots:** Use `<slot>` for content projection, allowing parent components to pass markup into child components for flexibility. Use named slots (`<slot name="header">`) for multiple content areas. Use `let:` directives (`<slot let:item={item}>`) to pass data back up to the parent from the slot content.
* **Avoid Direct DOM Manipulation:** Leverage Svelte's reactivity and template syntax instead of manually manipulating the DOM (e.g., using `document.querySelector`). Use `bind:this` only when necessary to get a direct reference to a DOM element (e.g., for integrating third-party libraries or managing focus).
* **Actions (`use:action`):** Use Svelte Actions for reusable logic related to element lifecycle and behavior (e.g., lazy loading images, tooltips, integrating external libraries).

## Reactivity (`$` and Stores)

* **Reactive Declarations (`$`):** Use reactive declarations (`$: variable = expression;`) for values that depend on other reactive variables. Svelte automatically re-runs these statements when their dependencies change. Keep reactive blocks concise and focused.
* **Reactive Statements (`$:{...}`):** Use reactive statements (`$: { ... }`) for running side effects (like logging or dispatching events) in response to state changes. Avoid overly complex logic in these blocks.
* **Stores:** Use Svelte Stores (`writable`, `readable`, `derived`) for managing state that needs to be shared across multiple components *without* prop drilling.
    * **Writable Stores:** For state that can be updated from components (`store.set()`, `store.update()`).
    * **Readable Stores:** For state that should only be set from within the store's definition (e.g., timers, external data sources).
    * **Derived Stores:** For state that depends on the value of one or more other stores.
* **Auto-Subscription (`$` Prefix):** Access store values directly in templates and script blocks using the dollar-sign prefix (`$storeName`). Svelte automatically manages subscription and unsubscription. Avoid manual `.subscribe()` in components unless you need more control (e.g., side effects on change), and if you do, *always* unsubscribe (e.g., in `onDestroy`).
* **Store Organization:** Define stores in dedicated files within `src/lib/stores/` (or similar). Keep stores focused on specific domains of state. Avoid monolithic stores.
* **Immutability (Optional but Recommended):** Consider using immutable updates with stores (`store.update(n => n + 1)`) or immutable data structures, especially for complex state, to potentially simplify reasoning and work better with `{#key}` blocks or future Svelte features. Use `<svelte:options immutable={true} />` if enforcing immutability at the component level.

## Styling (`<style>`)

* **Scoped Styles:** Styles defined within a component's `<style>` block are scoped to that component by default. Leverage this to write simpler, less specific selectors without fear of conflicts.
* **Global Styles:** Use the `:global()` modifier sparingly for targeting elements outside the component's scope or applying global base styles (often placed in a root layout or imported CSS file).
* **CSS Variables:** Use CSS Custom Properties (variables) for theming and passing dynamic style values down to child components effectively, often preferable to `:global()` overrides or `style:` directives for complex cases.
* **`style:` Directive:** Use the `style:` directive for simple dynamic inline styles (e.g., `style:color={myColor}`).
* **`class:` Directive:** Use the `class:` directive for toggling individual classes based on boolean values (e.g., `class:active={isActive}`).
* **Preprocessors:** Use CSS preprocessors like SCSS or PostCSS by configuring `svelte-preprocess` (or Vite's built-in support).

## Performance

* **Compiler Focus:** Understand that Svelte is a compiler. Much optimization happens at build time, resulting in small, efficient JavaScript bundles. Write straightforward code that the compiler can easily optimize.
* **Reactivity:** Leverage Svelte's fine-grained reactivity. Updates are surgical; avoid patterns that cause unnecessary recalculations in reactive (`$:`) blocks.
* **Lazy Loading (SvelteKit):** Utilize SvelteKit's file-based routing which often enables automatic code splitting and lazy loading for routes. Use dynamic `import()` for component-level lazy loading if needed outside of routing.
* **`{#key}` Block:** Use `{#key expression}` blocks to force a block of markup (and its components) to be destroyed and recreated when the `expression` value changes. Useful for resetting component state or re-triggering transitions when a key piece of data changes. Use judiciously.
* **`{#each}` `key`:** Always provide a unique key for `{#each}` blocks (`{#each items as item (item.id)}`) to allow Svelte to efficiently diff and update the list.
* **Minimize DOM Updates:** Structure components and reactivity to minimize unnecessary DOM updates. Use `#key` or derived stores if complex computations are re-running too often.
* **Bundle Analysis:** Keep an eye on production bundle size. Remove unused dependencies. Use SvelteKit adapters for optimized outputs for specific platforms.

## Security

* **XSS Prevention:** Svelte automatically escapes text inserted using curly braces (`{expression}`). Do NOT use `@html` with untrusted, user-provided content, as this bypasses escaping and creates an XSS vulnerability. Sanitize HTML content rigorously if `@html` is absolutely necessary with potentially unsafe data.
* **Attribute Escaping:** Attribute values are typically handled safely, but be cautious when binding potentially malicious URLs to `href` or `src` attributes. Validate external URLs.
* **Server-Side Security (SvelteKit):** Remember that code in `+server.js` or `load` functions running on the server has access to server-side resources and environment variables. Apply standard backend security practices: validate input, use parameterized queries, handle secrets securely, implement proper authentication/authorization. Do not expose secrets to client-side code via `load` functions unless explicitly intended and safe (`PUBLIC_` prefix for environment variables).
* **CSRF Protection (SvelteKit):** SvelteKit includes built-in CSRF protection for form actions and server endpoints using the `POST`, `PUT`, `PATCH`, or `DELETE` methods. Ensure this is enabled and utilized.
* **Dependencies:** Regularly audit dependencies (`npm audit`) for known vulnerabilities.

## SvelteKit Specifics

* **Routing:** Leverage file-based routing in `src/routes/`. Use layout files (`+layout.svelte`) for shared UI structure.
* **Loading Data (`load` functions):** Use `load` functions in `+page.js` (runs on server and client) or `+page.server.js` (runs only on server) to fetch data for pages. Return data from `load` functions; it becomes available via the `data` prop in the corresponding `+page.svelte`. Ensure `load` functions handle errors gracefully.
* **Form Actions:** Use SvelteKit Form Actions for handling form submissions securely and progressively enhanced. Validate data within the action on the server.
* **API Routes (`+server.js`):** Create API endpoints using `+server.js` files, exporting functions named after HTTP methods (`GET`, `POST`, etc.). Apply security best practices (validation, auth) here.
* **Hooks (`hooks.server.js`, `hooks.client.js`):** Use hooks for logic that needs to run on every request (server) or before navigation (client), e.g., authentication checks, custom response handling, adding security headers.
* **Environment Variables:** Access environment variables securely using modules like `$env/static/private`, `$env/dynamic/private` (server-only) and `$env/static/public`, `$env/dynamic/public` (shared). Only variables prefixed with `PUBLIC_` (by default) are exposed to the browser. Store secrets only in private env vars.
* **Adapters:** Choose the correct SvelteKit adapter (`adapter-node`, `adapter-vercel`, `adapter-static`, etc.) based on your deployment target and configure it appropriately.
* **SSR/SSG/SPA:** Understand the rendering modes (SSR, SSG, SPA, prerendering) offered by SvelteKit and configure them appropriately per-page or globally based on requirements for performance, SEO, and data freshness.
