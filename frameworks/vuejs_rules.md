# Vue.js Rules

## General Principles & Style

* **Follow JS/TS Rules:** Adhere to all rules defined in `javascript_typescript_rules.md`.
* **Vue Style Guide:** Follow the official Vue Style Guide (especially Priority A and B rules) for conventions regarding component naming, structure, prop definitions, template directives, etc.
* **Consistency:** Maintain consistency in naming, file structure, API choice (Composition vs. Options), and coding patterns throughout the project.
* **Readability:** Write clean, readable, and maintainable code. Keep components focused.
* **Tooling:** Use linters (ESLint with `eslint-plugin-vue`) and formatters (Prettier) configured for Vue projects to enforce standards automatically.

## Project Structure

* **Standard Structure:** Utilize the project structure generated by standard tooling like Vue CLI or Vite (recommended for Vue 3+). Keep source code primarily within `src/`. Common subdirectories:
    * `src/components/`: Reusable UI components.
    * `src/views/` or `src/pages/`: Route-level components.
    * `src/router/`: Vue Router configuration.
    * `src/store/` or `src/stores/`: State management stores (Pinia/Vuex).
    * `src/composables/`: Reusable Composition API functions.
    * `src/services/` or `src/api/`: Logic for interacting with external APIs.
    * `src/assets/`: Static assets like images, fonts.
    * `src/styles/` or `src/assets/styles/`: Global styles, variables, mixins.
* **File Naming:** Use `PascalCase` or `kebab-case` for component file names (e.g., `UserProfile.vue` or `user-profile.vue`). Be consistent within the project. Prefer `PascalCase` as it matches component name casing in scripts.

## Components (Single File Components - SFCs)

* **SFCs:** Use Single File Components (`.vue` files) to encapsulate template, script, and style for a component.
* **Naming:**
    * Component names (in `<script>` and when registering) should always be multi-word and `PascalCase` (e.g., `UserProfile`, `BaseButton`). Avoid single-word names to prevent conflicts with current or future HTML elements.
    * Use consistent prefixes for base/common components (e.g., `BaseButton`, `AppIcon`) and single-instance components (e.g., `TheHeader`, `TheSidebar`).
    * Tightly coupled child components should be prefixed with their parent's name (e.g., `UserListItem` used within `UserList`).
* **Props:**
    * Define props clearly using object syntax with `type`, `required`, `default`, and `validator` where appropriate. Avoid just using an array of strings.
    * Use `camelCase` for prop names in JavaScript/TypeScript.
    * Use `kebab-case` when passing props in templates (`<user-profile :user-id="userId">`). Vue automatically converts between them.
* **Component Size & Responsibility:** Keep components small and focused on a single responsibility. Extract sub-components if a component becomes too large or complex.
* **`emits` Option:** Declare emitted events using the `emits` option (Vue 3) for clarity and self-documentation. Use `kebab-case` for event names when emitting (`this.$emit('update-user')`) and listening (`@update-user="handleUpdate"`).
* **Slots:** Use slots (`<slot>`) for content distribution, allowing parent components to inject content into child components for flexibility. Use named slots for multiple content injection points.

## Templates (`<template>`)

* **Directive Shorthands:** Use directive shorthands: `:` for `v-bind`, `@` for `v-on`, and `#` for `v-slot`.
* **`key` with `v-for`:** Always provide a unique `key` attribute when using `v-for` to help Vue track node identity efficiently. Do not use the loop index as the key if the list order can change or items can be inserted/deleted non-sequentially. Use a unique ID from the item itself.
* **Avoid `v-if` with `v-for`:** Never use `v-if` on the same element as `v-for`. Filter the data source using a computed property *before* iterating with `v-for`. `v-for` has higher priority than `v-if`.
* **Simple Expressions:** Keep expressions within templates simple. Move complex logic into computed properties or methods in the script section.
* **Attribute Quoting:** Use double quotes (`"`) for HTML attribute values.
* **Self-Closing Components:** Use self-closing tags for components with no slot content in SFC templates (e.g., `<MyComponent/>`).

## Composition API vs. Options API

* **Prefer Composition API (Vue 3+):** For new Vue 3 projects, prefer the Composition API (using `<script setup>`) for better logic organization, reusability (composables), and TypeScript integration.
* **Options API:** Still valid, especially for simpler components or migrating Vue 2 projects. Can be easier for beginners to grasp initially due to its structured options (`data`, `methods`, `computed`, `watch`).
* **Consistency:** Choose one primary API style (Composition or Options) for the project and apply it consistently. Mixing them within a single component is possible but generally discouraged unless migrating gradually.
* **Composition API Best Practices:**
    * Organize logic by feature within `setup()` or `<script setup>`.
    * Use `ref()` for primitive reactive values and `reactive()` for objects. Understand the difference and `.value` access for `ref`.
    * Use `computed()` for derived state.
    * Use `watch()` or `watchEffect()` for reacting to state changes and performing side effects. Choose `watch` for specific sources and `watchEffect` for automatic dependency tracking.
    * Encapsulate reusable stateful logic into "Composable" functions (e.g., `useMousePosition()`, `useFetch()`).
    * Manage lifecycle hooks using `onMounted`, `onUnmounted`, etc.

## State Management

* **Local State:** Use `ref` or `reactive` within components for state local to that component.
* **Props & Events:** Use props down / events up for communication between parent and child components.
* **Provide/Inject:** Use `provide` and `inject` for passing data deeply through a component tree without prop drilling, but use with caution as it makes dependencies less explicit.
* **Composable Functions:** Share cross-component state using reactive values exported from composable functions (e.g., `export const store = reactive({...})`). Suitable for simple to moderate global state.
* **Pinia (Recommended):** For complex global state management in Vue 3, use Pinia (the official recommendation). Define modular stores, use getters for derived state, and actions for mutations (sync or async).
* **Vuex:** The previous official state management library. Still functional but Pinia is preferred for new Vue 3 projects due to simpler API and better TypeScript support.

## Routing (Vue Router)

* **Use Vue Router:** Use the official `vue-router` library for client-side routing.
* **Configuration:** Define routes clearly, often in a dedicated `src/router/index.js` (or `.ts`) file.
* **Lazy Loading:** Use dynamic imports (`() => import('./views/AboutView.vue')`) for route components to enable route-based code splitting (lazy loading). This improves initial load performance.
* **Route Guards:** Use navigation guards (`beforeEach`, `beforeEnter`, `beforeRouteEnter`, etc.) for implementing authentication, authorization, or other pre-navigation logic.
* **Named Routes:** Use named routes and `router-link`'s `:to="{ name: 'user', params: { id: 123 } }"` prop for programmatic navigation and easier route management.

## Security

* **XSS Prevention:** Vue automatically escapes content bound using text interpolation (`{{ }}`) and `v-bind`. Be extremely cautious when using `v-html` â€“ only use it on trusted content and NEVER on user-provided content unless explicitly sanitized by a trusted library on the server-side *and* client-side if necessary.
* **Attribute Binding:** Avoid binding `href`, `src`, or `style` attributes directly to user-provided URLs or CSS without sanitization or validation, as this can lead to vulnerabilities.
* **Avoid Non-Trusted Templates:** Never use user-provided strings as component templates.
* **Server-Side Rendering (SSR) Security:** Be mindful of XSS risks when using SSR if user data is incorporated into the initially rendered HTML without proper escaping/sanitization on the server.
* **Dependency Security:** Regularly audit dependencies (`npm audit`) for known vulnerabilities.

## Performance

* **Lazy Loading:** Use lazy loading for routes and components (see Routing and Components).
* **Code Splitting:** Leverage bundler features (like Vite or Webpack) for automatic or manual code splitting.
* **`v-show` vs. `v-if`:** Use `v-show` (toggles `display: none`) for elements frequently toggled, as the initial render cost is paid upfront. Use `v-if` (actually adds/removes element from DOM) for conditional rendering where the condition rarely changes or when initial render cost needs to be deferred.
* **`v-for` `key`:** Always use `:key` with `v-for` (see Templates section).
* **Optimize Computed Properties:** Keep computed properties efficient. Cache expensive computations.
* **Virtual Scrolling:** For rendering very long lists, use virtual scrolling libraries (e.g., `vue-virtual-scroller`) to render only the visible items.
* **Bundle Analysis:** Analyze production bundle size using tools provided by Vite/Webpack and optimize accordingly (e.g., remove unused dependencies, optimize assets).
* **Memoization (`v-memo`):** Use the `v-memo` directive (Vue 3.2+) to conditionally skip updates for large subtrees or `v-for` loops if the dependency values haven't changed.

## Testing

* **Component Testing:** Write unit tests for components using the Vue Test Utils library with Jest, Vitest, or Mocha.
* **Component Isolation:** Test components in isolation, mocking dependencies as needed.
* **Snapshot Testing:** Use snapshot testing for UI components to detect unintended UI changes.
* **E2E Testing:** Use Cypress, Playwright, or Nightwatch for end-to-end testing of complete user flows.
* **Test Coverage:** Aim for good test coverage, especially for complex components and business logic.

## Vue 3 Specific Best Practices

* **TypeScript Integration:** Leverage Vue 3's improved TypeScript support with proper type annotations for props, emits, and component definitions.
* **Teleport:** Use the `<Teleport>` component to render content at a different place in the DOM while keeping the component hierarchy intact (e.g., for modals, tooltips).
* **Fragments:** Take advantage of Vue 3's support for multiple root elements in a component template (fragments).
* **Suspense:** Use the `<Suspense>` component for handling async components and showing fallback content while they load.
* **Setup Script:** Prefer the more concise `<script setup>` syntax over the regular `setup()` function for Composition API components.
* **CSS Variables Binding:** Use Vue 3's ability to bind reactive state to CSS variables for dynamic styling without component re-rendering.
