# Contract Testing Rules

## Purpose & Goals

* **Goal:** Ensure that independently developed services (consumers and providers) can communicate correctly by verifying that they adhere to a shared understanding (a "contract") of their interactions (API requests/responses or messages).
* **Why:**
    * Enable independent deployment of services with confidence.
    * Provide fast, reliable feedback on integration points without the cost, complexity, and brittleness of full end-to-end integration tests.
    * Detect breaking changes in provider APIs *before* they impact consumers in production.
    * Serve as living documentation for service interactions.
* **Focus:** Verify the *interface contract* (structure, data types, status codes, headers, message format) between a consumer and a provider, not the provider's internal business logic or the consumer's UI behavior.

## When to Use Contract Testing

* **Microservices Architectures:** Essential for managing interactions between independently deployed services.
* **API Integrations:** When integrating with internal or external APIs where compatibility is crucial.
* **Message Queues/Event Streams:** Verifying that message formats produced match consumer expectations.
* **Replacing Brittle Integration Tests:** Use contract tests to gain faster, more reliable feedback on service interactions, reducing reliance on slow, flaky end-to-end tests for this specific purpose.

## Approach: Consumer-Driven Contract Testing (CDCT)

* **Principle:** The *consumer* defines the interactions (requests it will send, responses it expects) based on its specific needs. These expectations form the contract. The *provider* then verifies that it can fulfill this contract.
* **Benefits:** Ensures the provider only builds and maintains what consumers actually need and prevents providers from making breaking changes unknowingly.

## Workflow (Using Pact as an example)

1.  **Consumer Side:**
    * **Write Consumer Tests:** In the consumer's codebase, write tests (typically unit or integration tests) that interact with a *mock provider* (e.g., configured via Pact's mock service).
    * **Define Interactions:** Within these tests, define the specific requests the consumer will send and the *minimal expected response* structure and data it needs from the provider for that interaction. Use matchers (e.g., type matching, regex matching) instead of exact values where appropriate to make contracts less brittle.
    * **Generate Contract (Pact File):** Upon successful execution of the consumer tests against the mock provider, the testing framework (e.g., Pact JS, Pact JVM) generates a contract file (the "Pact") containing the defined interactions.
    * **Publish Contract:** Publish the generated Pact file to a central location, typically a Pact Broker or Pactflow. Include consumer version information when publishing.

2.  **Provider Side:**
    * **Retrieve Contract:** The provider retrieves the relevant consumer contracts (Pacts) from the Pact Broker.
    * **Verify Contract:** In the provider's codebase/CI pipeline, run verification tests. The Pact framework (e.g., Pact Provider Verifier) replays the requests defined in the contract against the *actual* running provider service (or a test instance).
    * **Compare Responses:** The framework compares the actual responses generated by the provider with the expected responses defined in the contract.
    * **Publish Results:** Publish the verification results (success or failure) back to the Pact Broker.

3.  **CI/CD Integration & Deployment:**
    * **Consumer Pipeline:** Run consumer tests and publish the pact on successful builds.
    * **Provider Pipeline:** Fetch relevant pacts and run provider verification tests. Fail the build if verification fails.
    * **Deployment Gating (`can-i-deploy`):** Before deploying a consumer or provider, use the Pact Broker's `can-i-deploy` tool/API check to ensure the version being deployed is compatible with the latest verified versions of its counterparts currently deployed in the target environment. Prevent deployment if compatibility checks fail.

## Contract Design Best Practices

* **Consumer-Driven:** Contracts should reflect the consumer's *actual* requirements, not the provider's entire API surface.
* **Minimal Expectations:** Consumers should only specify the parts of the request/response they actually care about. Use appropriate matchers (type, regex, presence/absence) rather than hardcoding exact values where flexibility is needed. This makes contracts less brittle to provider changes that don't affect the consumer.
* **Isolate Interactions:** Each interaction defined in a contract should represent a distinct scenario or request/response pair.
* **Provider States:** Use "Provider States" (Pact term) to define the necessary preconditions on the provider side for a specific interaction to occur (e.g., "a user with ID 123 exists", "the shopping cart is empty"). The provider verification setup uses these states to ensure the provider is in the correct state before replaying the request.
* **Focus on Interface:** Test the contract (data structure, types, status codes, headers), not the provider's business logic.

## Pact Broker / Contract Sharing

* **Use a Broker:** Use a Pact Broker (like the open-source Pact Broker or a managed service like PactFlow) to facilitate sharing contracts and verification results between consumer and provider teams. Avoid sharing contract files manually (e.g., via email or shared drives).
* **Tagging & Versioning:** Use application versions and environment tags effectively when publishing pacts and verification results to the broker. This enables `can-i-deploy` checks and better visibility.
* **Webhooks:** Configure broker webhooks to trigger provider builds automatically when consumer contracts change, providing faster feedback.

## CI/CD Integration

* **Automate Everything:** Automate consumer pact generation, provider verification, and `can-i-deploy` checks within CI/CD pipelines.
* **Fail Fast:** Fail builds immediately if consumer tests fail to generate a contract or if provider tests fail verification.
* **Deployment Safety:** Use `can-i-deploy` checks as a quality gate before deploying any service to ensure compatibility with its integrated counterparts.

## General Best Practices

* **Collaboration:** Contract testing requires collaboration between consumer and provider teams, especially when defining initial contracts or handling breaking changes. The contract serves as a communication tool.
* **Scope:** Use contract testing for verifying direct interactions between services/components. It complements, but does not replace, unit tests (for internal logic) or a *small* number of end-to-end tests (for critical user flows).
* **Start Small:** Introduce contract testing gradually, perhaps starting with a single consumer-provider relationship before rolling it out more broadly.
* **Keep Tests Fast:** Contract tests should be significantly faster than traditional end-to-end integration tests. Ensure they run quickly within CI pipelines.
